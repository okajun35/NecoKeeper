# AI主導でFastAPIのWebサービスを作るとき、人間が構造化すべき境界線

PyCon mini Shizuoka 2026 向け発表ドラフト（30分）

- 会場: コクリ
- 発表者: XXXX（匿名箇所は後で置換）
- 形式: 発表30分（質疑応答は時間があれば）
- 対象: All（エンジニア以外も含む）

---

## 0. タイトル

### 0-1 タイトル

- AI主導でFastAPIのWebサービスを作るとき、人間が構造化すべき境界線
- PyCon mini Shizuoka 2026
- XXXX

最後の一言:
今日は技術の紹介というより、AI時代に「どう判断してシステムを作るか」の話をします。

### 0-2 自己紹介

- 名前: XXXX
- 職業: Web系エンジニア / PM / SIer
- 個人開発歴: インディーズゲーム、iPhoneアプリ、Webシステム
- 使っているAI: Kiro / Codex / GitHub Copilot / Google系AI など

### 0-3 今日話すこと / 話さないこと

話すこと:
- AI主導開発で、人間が先に決めるべきこと
- 個人開発でAIを使って良かった点・つまずいた点

話さないこと:
- 各技術の詳細な使い方
- プロンプトの細かい書き方

---

## 1. オープニング（完成しない理由）

### 1-1 問いかけ

- 個人開発で「途中まで作って止まる」を何度も経験した

### 1-2 よくある完成しない流れ

- 作りたいものはある
- 手を動かす
- 少し動く
- 触らなくなる

### 1-3 よく言われる理由

- 実現方法が分からない
- エラーが直せない
- 時間がない
- モチベーションが続かない

最後の一言:
どれも要因だが、決定打ではない。

### 1-4 本当の原因（仮説）

- 開発が止まる瞬間は「判断できなくなったとき」
- 何が正しいか分からない
- これでいいのか決められない

最後の一言:
問題は気合ではなく、判断可能性の設計。

---

## 2. AIで変わったこと

### 2-1 AIで解消されたもの

- 実装速度
- エラー解決の初速
- 壁打ち相手の不在

最後の一言:
実装で止まることは減った。

### 2-2 それでも残るもの

- どこまで作るか
- 何を捨てるか
- 何を正とするか

最後の一言:
判断はAIに委譲しきれない。

### 2-3 今日の主張

- AI時代でも「判断の設計」は人間の仕事

---

## 3. NecoKeeper紹介

### 3-1 何を作ったか

- NecoKeeper: 保護猫団体向けのAI活用Webアプリ
- 紙運用（世話記録・医療メモ）をデジタル化し、保護から譲渡までを一元管理
- 主機能（Devpost掲載内容ベース）:
  - MCP + 自然言語による猫登録
  - QRベース世話記録（ログイン不要入力に対応）
  - 医療/譲渡管理、QRカード・帳票PDF生成
  - Kiroween向けの「Necro-Terminal Mode」

参照:
- https://devpost.com/software/necokeeper

### 3-2 現場課題とPOC状況

- 実際の保護猫カフェでPOC運用中
- 解決したい課題:
  - 紙で世話記録
  - 後でExcelへ転記
  - 二重入力と検索性の低さが発生
- ペルソナ:
  - 現地スタッフ（ボランティア）:
    - 紙でも運用可能
    - 1週間程度の短期記録を、素早く簡単に残せることが重要
  - 保護猫団体の管理者:
    - 中長期の記録を残して検索したい
    - 自治体提出用の書類を作りたい
  - 自治体:
    - 保護猫管理が適切かを年単位で確認したい
- 目標:
  - ボランティアにとってスマホで入力しやすく
  - 管理者にとって追跡・提出しやすいシステム

### 3-3 規模感（実測）

- 画面: 31
- DBテーブル数: 15
- コード行数
  - Backend Python: 17,000
  - HTML: 7,000
  - JavaScript（`app/static/js/`）: 10,000 ※今後の改善項目
- 主要技術スタック:
  - Backend: FastAPI / SQLAlchemy / Alembic / Pydantic
  - Frontend: Jinja2 Templates / Vanilla JavaScript
  - Database: SQLite
  - Tooling: Ruff / mypy / pytest
  - Integration: MCP（Automation API連携）/ PDF生成（WeasyPrint）

補足:
- 新規開発 約1か月（実装3週間 + 動画・仕上げ1週間）

### 3-4 代表機能（5つ）

- 保護猫マスタ管理（登録・一覧・詳細・編集）
- 世話記録入力/可視化（公開フォーム + 管理画面）
- 医療記録/処置管理
- 里親応募/譲渡管理
- 帳票出力 + Automation API連携

最後の一言:
規模の大小に関係なく、開発は「判断の連続」です。

---

## 4. 開発前提とKiro

### 4-1 前提条件

- ハッカソン制約（短期・完成優先・失敗許容）
- 「自分はコードを書かず、設計意図と制約を渡す」方針

### 4-2 前提ドキュメント（Spec）と Vibe coding の使い分け

- ここでいうSpecは、Kiro固有機能ではなく「実装前に判断を固定する文書」の総称
- 前提ドキュメント（Spec相当）: 目的・制約・非目標・成功条件・受け入れ条件を先に固定
- Vibe coding: 対話で高速に試作・修正
- 対立ではなく役割分担

最後の一言:
前提ドキュメントで方向を固定し、Vibe codingで速度を出す。

### 4-3 Kiro / Kiroween 背景

- Kiro（公式）:
  - 「prototype から production までの Agentic AI 開発」を掲げるAI IDE/CLI
  - 自然文プロンプトから要件・受け入れ基準（EARS）を構造化し、設計・タスク化まで支援
  - `Specs / Steering / Hooks / MCP` で、速度だけでなく一貫性を担保する思想
- Kiroween（公式）:
  - Kiro公式の年次ハッカソン（2025年10月31日〜12月5日、オンライン）
  - 要件は「Kiroを使った動くソフトウェア」を提出すること
  - 提出物は、公開OSSリポジトリ（`/.kiro` 必須）、3分デモ動画、Kiro活用の説明など
  - 審査軸は Potential Value / Implementation（Kiro活用度）/ Quality and Design
- NecoKeeperはこのKiroweenへの提出作品（Devpost上で公開）

参照:
- https://kiro.dev/
- https://kiroween.devpost.com/
- https://devpost.com/software/necokeeper

---

## 5. 壊れたポイント

### 5-1 AI主導開発で壊れやすい場所

- ここで言う「壊れる」とは、アプリが完全停止することだけではない
  - 画面ごとに挙動が違う
  - 同じデータの意味が場所ごとにズレる
  - 機能追加時に思わぬ副作用が出る
- よく起きる3つのズレ:
  - 認証実装のズレ（ログイン判定の方法が揃っているか）:
    - 例: ある画面はサーバー側で認証するが、別画面はJS判定だけで保護されていない
  - データ定義のズレ（何を正しいデータとして保存するか）:
    - 例: 画面表示の値とDBの値で意味がズレ、集計結果が合わなくなる
  - 実装場所のズレ（どこでルールを判断するか）:
    - 例: ルールが画面・API・DBに分散し、修正時に漏れが出る

最後の一言:
壊れたのはコード単体より、前提のズレ。

### 5-2 機械で直せる問題（技術スタック連動）

- 機械で直しやすい領域:
  - フォーマット/静的解析: `Ruff`（format, lint）
  - 型不整合: `mypy`
  - 回帰不具合: `pytest`
  - 入力不正/スキーマ不整合: `Pydantic`（FastAPIリクエスト検証）
- AIが直せる理由:
  - ツールがエラー位置と理由を機械可読で返す
  - AIはその差分を読んで、修正→再実行を反復できる
- 運用の実態:
  - makeファイルで実行できるようにした
    - `make format` / `make lint` / `make mypy` / `make test` を基準に検知
  - エラーの再現性が高いものは、AI主導で修正を進めやすい

最後の一言:
「検知ルールが明確な問題」は、AIと自動化で高速に回せる。

### 5-3 本当に難しい問題（先に決めるべきもの）

- データモデル/テーブル構造の初期設計:
  - 今回はGoogleフォームとSpreadsheetで、必要な項目と値の粒度を先に検証
  - この整理なしで列追加を繰り返すと、後で整合性と検索性が崩れやすい
- ビジネスロジックと実装の整合:
  - 前提ドキュメントに書いた意図と、実装の挙動が一致しているか
  - そもそもの考慮漏れ（人間側の想定不足）も発生する
- 「何を正とするか」の定義:
  - 今回は最終的に、E2Eで人間がブラウザ操作して期待挙動を確認する方式を採用

### 5-4 不一致が出たときの進め方

- 自動E2E（機械）が得意なこと:
  - 既知シナリオの回帰検知（同じ手順を何度も再実行）
  - 「壊れていないこと」の継続監視
- 人間E2Eが得意なこと:
  - モーダルが開かない、画面が崩れる、導線が分かりにくい等の違和感検知
  - 画面操作の結果が、実際にDBへ期待どおり保存されているかの確認
- 今回の運用:
  - AIで修正 → 人間がブラウザで操作確認 → 必要に応じてDB確認
  - 問題があれば再修正し、判断ログ/設計ドキュメントへ反映
- メンタル面の効果:
  - 画面を実際に触って前進を確認できるため、開発の手応えを維持しやすい


## 6. FastAPIで固定すべき構造

### 6-1 認証依存の境界（Dependsの置き場所）

- 認証判定を「各エンドポイントごと」から「ルーター単位」へ昇格させる
- 認証のやり方（方式・対象範囲・未認証時挙動）を先に固定する
- 未認証時の処理は、エンドポイント内に散らさない
- 認証ロジックは共通化して、参照点を1つにする
- 認証を「関数実装」ではなく「構造」で守る

図（スライド用）

[Browser]
↓
[Auth layer（未認証時挙動を統一）]
↓
[Protected Router（認証依存をまとめて適用）]
↓
[Endpoints]

---

### 6-2 ルーター分割の境界

- 「管理者向け」と「一般向け」をルーター単位で分離する
- 認証が必要な領域は、URLのまとまり（prefix）として明確化する
- APIと画面（HTML）をルーターで分け、責務を混ぜない
- 「どの経路が守られているか」を構造で見えるようにする

---

### 6-3 ミドルウェアの境界

- 未認証アクセス時の挙動を、ミドルウェア層で統一する
- 画面アクセス：ログインへ誘導／APIアクセス：401など、方針を固定する
- エンドポイント内に未認証分岐を書かない
- 例外処理・遷移・ログを構造レイヤーに押し上げる

締めの一言：

FastAPIでは、Depends・Router・Middlewareの3点を人間が先に固定しないと、AI実装は不安定になる。


---

## 7. 失敗事例（30秒）

### 7-1 認証のBefore / After

Before:
- 認証仕様を先に固定せず、画面単位で実装を積み上げた
- 管理画面を返す時点で、サーバー側の認証確認が抜ける経路があった
- 認証チェックをフロント側のトークン存在確認と、APIの401時リダイレクトに依存していた
- 結果として、認証判定の場所が散らばり、未認証時挙動に不整合が出た

After:
- 認証仕様を先に文書化（方式、保護対象、未認証時挙動、アクセスルール）
- 仕様参照で再実装し、認証判定を共通化
  - トークンの取得・検証をバックエンドの共通認証処理に集約
  - 未認証時の遷移とレスポンス方針をミドルウェアで統一

学び:
- 認証は「実装で合わせる」のではなく「仕様を先に固定する」

---

## 8. 汎用化したズレ防止チェックリスト

### 8-1 認証実装のズレ（ログイン判定の方法が揃っているか）

- 認証方式の使い分けを固定したか（例: OAuth2/JWT、API Key、公開API）
- トークン取得と検証ロジックを共通化したか
- 未認証時の挙動を統一したか（HTMLはログイン画面へ、APIは401 JSONなど）

### 8-2 データ定義のズレ（何を正とするか）

- 正とするデータ源は明確か
- 現在値と履歴の役割を分離したか
- 更新/削除/整合性ルールを決めたか
- 具体例（年齢表現）:
  - 初期案（AI提案）: 子猫 / 成猫 / 老猫
  - 現場ヒアリング: 外見で年齢判定は難しく、運用上も粗すぎる
  - 補足: 学術的にも固定の3区分が標準というわけではない
  - 判断: 月齢中心の入力へ変更（必要に応じて推定フラグを併用）
  - 学び: 「わかりやすさ」より「現場で意味があるか」を優先
- 具体例（ペットフード情報を記録するか）:
  - 初期案: メーカー/商品をマスター管理して記録する
  - 検討:
    - ボランティアが日々の記録で餌の種類と量を毎回入力するのは負担が高い
    - 何を実現したいか（例: 在庫管理）という目的が曖昧で、機能追加の根拠が弱い
    - 「スマホで簡単にポチポチ入力する」という運用コンセプトに反する
  - 判断: 初期リリースでは見送り、将来拡張項目として扱う

### 8-3 実装場所のズレ（どこで判断するか）

- 画面/API/業務ロジック/DBの責務を分けたか
- バリデーション位置を定義したか
- 仕様変更時の影響範囲を追えるか
- 具体例（世話記録の「排便」項目の入力ルール）:
  - 状況: 既存記録を編集して「排便なし」に変えたとき、以前入力した「便の状態」が残って保存エラーになることがあった
  - 問題: 画面の入力手順に依存すると、操作順で結果が変わり不整合が起きる
  - 判断: この判定は画面ではなくサーバー側で統一し、「排便なし」なら「便の状態」を自動で空にする
  - 学び: 業務ルールはバックエンドで一貫して守ると壊れにくい

締め:
- この3つのズレを先に定義すると、AI実装の速度を落とさずに破綻を防げる。

---

## 9. 明日から使える実践フォーマット

### 9-1 ドキュメントを先に作る（最小セット）

- `前提ドキュメント（Spec相当）`（目的 / 制約 / 非目標 / 成功条件 / 受け入れ条件）
- `判断ログ`（論点 / 選択肢 / 採用理由 / 見直し条件）
- `ズレ防止ルール`（認証実装 / データ定義 / 実装場所）
- 何を残すかの判断軸:
  - 影響範囲が広い（複数画面・複数APIに効く）
  - 後戻りコストが高い（DB/API/権限）
  - 情報源が衝突した（AI提案と現場ヒアリングが不一致）
  - 運用ルールとして再利用する
- 残さないもの:
  - 一時的な試行メモ
  - UIの微調整
  - コードを見れば分かる自明な実装詳細
- 原則: 将来「なぜそうしたか」を説明できないと困る判断だけ残す
- ツールは不問（Kiro専用ではない）

### 9-2 AIへの運用ルール

- 人間が事前に決めること:
  - 何を自動チェックで担保するか（Lint / 型チェック / 単体・APIテスト）
  - どこを人間が確認するか（E2E観点、運用上の受け入れ条件）
  - 何を優先して直すか（失敗時の優先順位）
- AIが担当すること（レビュー前の自動チェック）:
  - 実装前に前提ドキュメントと判断ログを参照
  - 実装後にフォーマット / 静的解析 / 型検査 / 自動テストの自動チェックを反復する
  - 必須の自動チェックを通らない変更は、コードレビューに上げない
- 人間が担当すること（最終判断）:
  - E2Eで画面操作し、期待挙動かを確認
  - 運用上の妥当性を判断して採否を決める
  - 矛盾があれば判断ログと設計ドキュメントを更新する
  - 最終的な成果物の責任を持つ

最後の一言:
- AIに任せる範囲と人間が決める範囲を先に固定し、判断軸を運用で保ち続ける。

### 9-3 短期AI開発で先に固定する3点

- 受け入れ条件:
  完了の定義を先に決める（何ができたらOKか）
- ズレ防止ルール:
  認証実装 / データ定義 / 実装場所を先に決める
- 最終責任:
  自動チェックはAIで回し、採否判断と成果物責任は人間が持つ

最後の一言:
- 速く作る前に、判断の土台を固定する。

---

## 10. まとめ

### 10-1 今日の要点

- AIで実装は速くなる
- でも、判断は残る
- 特に「ズレを防ぐ判断」は人間が引き取る
- 最終的な成果物の責任は人間が持つ
- AIはときに「間違えるのは人間」と言う。だからこそ、人間側は判断軸を先に設計して運用する。

### 10-2 持ち帰り3項目（再掲）

- 受け入れ条件を先に決める
- ズレ防止ルールを先に決める
- 最終責任は人間が持つ

### 10-3 クロージング

- これは正解の提示ではなく、2025年12月からの開発で得た試行錯誤の記録。
- AI駆動開発は変化が速い。今日は、現時点で有効だった進め方の一例として共有する。

最後の一言:
- AIが「間違えるのは人間」と言う時代だからこそ、構造を固定し、最終判断と成果物の責任は人間が持つ。

- ご清聴ありがとうございました。

## 11. 宣伝

- Kiroweenに出たことで、海外ハッカソンに出ることが怖くなくなった
- AWS主催の「10000 AIdeas Competition」に応募したところ、セミファイナルに選ばれた
- 3月にAWS Buildersで記事を書く予定。内容がよければ「いいね」をお願いします


---

## 参考リンク（発表末尾）

- PyCon mini Shizuoka 2026 info
  https://shizuoka.pycon.jp/2026/info
- Kiroween（Devpost）
  https://kiroween.devpost.com/
- NecoKeeper（Devpost）
  https://devpost.com/software/necokeeper
- Kiro
  https://kiro.dev/
- 参考: 過去のPyCon mini Shizuoka資料一覧
  https://pycon-shizu.connpass.com/event/337283/presentation/
  https://pycon-shizu.connpass.com/event/228219/presentation/
  https://pycon-shizu.connpass.com/event/152678/presentation/
- 参考: 過去登壇資料（本人）
  https://speakerdeck.com/okajun35/pythondedesukutotupuapuriwojian-dan-nizuo-rufang-fa

---

## 付録: 発表者ノート（非公開）

### N-1 30分時間配分（目安・最新版構成対応）

- 0. タイトル / 自己紹介: 2:30
- 1. オープニング（完成しない理由）: 2:30
- 2. AIで変わったこと: 1:40
- 3. NecoKeeper紹介: 4:00
- 4. 開発前提とKiro: 2:40
- 5. 壊れたポイント: 3:30
- 6. FastAPIで固定すべき構造: 3:00
- 7. 失敗事例（Before / After）: 2:00
- 8. ズレ防止チェックリスト: 3:00
- 9. 明日から使える実践フォーマット: 2:40
- 10. まとめ: 2:00
- 宣伝: 0:40
- バッファ（言い直し・間）: 3:50
- 合計: 30:00

### N-2 図・画面キャプチャ配置

### N-2 図・画面キャプチャ配置（最新版構成対応）

- 3-2 現場課題とPOC状況
  → ボランティア / 管理者 / 自治体の情報フロー図

- 3-3 規模感（実測）
  → 画面数 / テーブル数 / LOCの指標カード

- 4-2 Spec と Vibe coding の使い分け
  → 「固定（前提）」と「実装（対話）」の2レーン図

- 6-1 FastAPI構造
  → Auth layer → Router → Endpoint の構造図

- 7-1 認証のBefore / After
  → 認証判定の分散 → 共通化 の比較図

- 8-2 データ定義のズレ
  → AI案 / 現場ヒアリング / 採用判断 の3列比較

- 9-3 短期AI開発で先に固定する3点
  → 受け入れ条件 / ズレ防止ルール / 最終責任 の3分割図

- 画面キャプチャ
  → 公開入力フォーム
  → 管理画面
  → 帳票またはQR出力（各1枚）
